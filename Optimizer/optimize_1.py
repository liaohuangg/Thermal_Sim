import subprocess
import os
import re
import random
import time
import shutil
import matplotlib.pyplot as plt
from datetime import datetime
import csv
import glob
from PIL import Image
import math

class Block:
    def __init__(self, name, width, height, x, y, block_type=None):
        self.name = name
        self.width = float(width)
        self.height = float(height)
        self.x = float(x)
        self.y = float(y)
        self.type = block_type
        self.center_x = self.x + self.width / 2
        self.center_y = self.y + self.height / 2

    def __str__(self):
        return f"{self.name}\t{self.width:.6f}\t{self.height:.6f}\t{self.x:.6f}\t{self.y:.6f}"

    def copy(self):
        return Block(self.name, self.width, self.height, self.x, self.y, self.type)

    def distance_to(self, other_block):
        dx = self.center_x - other_block.center_x
        dy = self.center_y - other_block.center_y
        return math.sqrt(dx*dx + dy*dy)

class LayoutOptimizer:
    def __init__(self, config):
        self.config = config
        self.results_dir = f"results_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.results_dir, exist_ok=True)

        self.history = {
            'iteration': [],
            'temperature': [],
            'wire_length': [],
            'combined_cost': [],
            'layout_file': [],
            'thermal_image': [],
            'acceptance': [],
            'time': [],
            'chip_area': [],
            'score': []  
        }

        with open(os.path.join(self.results_dir, "optimization_history.csv"), "w") as f:
            f.write("Iteration,Temperature,WireLength,CombinedCost,LayoutFile,ThermalImage,Acceptance,Time,ChipArea,Score\n")
        
        # 创建原始数据记录文件
        self.raw_data_file = os.path.join(self.results_dir, "raw_metrics.txt")
        with open(self.raw_data_file, "w") as f:
            f.write("Iteration\tTemperature\tWireLength\n")

        self.block_types = self.parse_type_file(config.get("type_file", "ev6.type"))

    def parse_type_file(self, filename):
        block_types = {}
        if os.path.exists(filename):
            with open(filename, 'r') as f:
                for line in f:
                    if not line.strip():
                        continue
                    parts = line.split()
                    if len(parts) >= 2:
                        block_types[parts[0]] = parts[1]
        return block_types

    def parse_flp(self, filename):
        blocks = []
        with open(filename, 'r') as f:
            for line in f:
                if line.startswith('#') or not line.strip():
                    continue
                parts = line.split()
                if len(parts) == 5:
                    block_name = parts[0]
                    block_type = self.block_types.get(block_name, "unknown")
                    blocks.append(Block(block_name, parts[1], parts[2], parts[3], parts[4], block_type))
        return blocks

    def write_flp(self, filename, blocks):
        with open(filename, 'w') as f:
            f.write("# Floorplan generated by optimizer\n")
            f.write("# Format: <unit-name>\t<width>\t<height>\t<left-x>\t<bottom-y>\n\n")
            for block in blocks:
                f.write(f"{block}\n")

    def get_chip_bounds(self, blocks):
        width = max(block.x + block.width for block in blocks)
        height = max(block.y + block.height for block in blocks)
        return width, height

    def calculate_chip_area(self, blocks):
        width, height = self.get_chip_bounds(blocks)
        return width * height

    def check_overlap(self, block1, block2):
        if (block1.x + block1.width <= block2.x or
            block1.x >= block2.x + block2.width or
            block1.y + block1.height <= block2.y or
            block1.y >= block2.y + block2.height):
            return False
        return True

    def is_valid_position(self, block, blocks, chip_width, chip_height):
        if (block.x < 0 or block.y < 0 or
            block.x + block.width > chip_width or
            block.y + block.height > chip_height):
            return False
        for other in blocks:
            if block.name != other.name and self.check_overlap(block, other):
                return False
        return True

    def perturb_layout(self, blocks, chip_width, chip_height, expansion_factor=1.5):
        new_blocks = [block.copy() for block in blocks]
        idx = random.randint(0, len(new_blocks) - 1)
        block = new_blocks[idx]
        original_x, original_y = block.x, block.y
        max_attempts = 100
        expanded_width = chip_width * expansion_factor
        expanded_height = chip_height * expansion_factor
        for _ in range(max_attempts):
            max_x = expanded_width - block.width
            max_y = expanded_height - block.height
            block.x = random.uniform(0, max_x)
            block.y = random.uniform(0, max_y)
            block.center_x = block.x + block.width / 2
            block.center_y = block.y + block.height / 2
            if self.is_valid_position(block, new_blocks, expanded_width, expanded_height):
                return new_blocks
        block.x, block.y = original_x, original_y
        block.center_x = block.x + block.width / 2
        block.center_y = block.y + block.height / 2
        return new_blocks

    def calculate_wire_length(self, blocks):
        intq_block = None
        for block in blocks:
            if block.name == "IntQ":
                intq_block = block
                break
        if intq_block is None:
            print("警告: 未找到IntQ核心模块")
            return 0.0
        total_length = 0.0
        connection_count = 0
        for block in blocks:
            if block.type in ["process", "memory"] and block.name != "IntQ":
                distance = block.distance_to(intq_block)
                total_length += distance
                connection_count += 1
        if connection_count > 0:
            return total_length / connection_count
        return 0.0

    def run_hotspot_simulation(self, iteration, layout_file):
        iter_dir = os.path.join(self.results_dir, f"iteration_{iteration:03d}")
        os.makedirs(iter_dir, exist_ok=True)
        iter_layout_file = os.path.join(iter_dir, "ev6.flp")
        shutil.copy(layout_file, iter_layout_file)
        for file in ["run.sh", "example.config", "gcc.ptrace", "example.materials"]:
            if os.path.exists(file):
                shutil.copy(file, iter_dir)
        start_time = time.time()
        try:
            subprocess.run(["./run.sh"], cwd=iter_dir, check=True)
            out_dir = os.path.join(iter_dir, "outputs")
            os.makedirs(out_dir, exist_ok=True)
            for file in glob.glob(os.path.join(iter_dir, "gcc.*")):
                if os.path.isfile(file):
                    os.rename(file, os.path.join(out_dir, os.path.basename(file)))
            if os.path.exists(os.path.join(iter_dir, "outputs")):
                for file in os.listdir(os.path.join(iter_dir, "outputs")):
                    src = os.path.join(iter_dir, "outputs", file)
                    dst = os.path.join(out_dir, file)
                    if os.path.isfile(src):
                        shutil.move(src, dst)
            max_temp = 0.0
            steady_file = os.path.join(out_dir, "gcc.steady")
            if os.path.exists(steady_file):
                with open(steady_file, "r") as f:
                    for line in f:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 2:
                                try:
                                    temp = float(parts[1])
                                    max_temp = max(max_temp, temp)
                                except ValueError:
                                    continue
            thermal_image = ""
            png_files = glob.glob(os.path.join(out_dir, "*.png"))
            if png_files:
                thermal_image = png_files[0]
                try:
                    img = Image.open(thermal_image)
                    img.thumbnail((300, 300))
                    thumbnail_path = os.path.join(out_dir, "thumbnail.png")
                    img.save(thumbnail_path)
                except Exception as e:
                    print(f"创建缩略图失败: {e}")
            elapsed_time = time.time() - start_time
            return max_temp, thermal_image, elapsed_time, iter_layout_file  
        except Exception as e:
            print(f"仿真失败: {e}")
            elapsed_time = time.time() - start_time
            return float('inf'), "", elapsed_time, iter_layout_file

    def save_iteration_data(self, iteration, temperature, wire_length, combined_cost,
                           layout_file, thermal_image, acceptance, 
                           elapsed_time, chip_area, score=None):
        self.history['iteration'].append(iteration)
        self.history['temperature'].append(temperature)
        self.history['wire_length'].append(wire_length)
        self.history['combined_cost'].append(combined_cost)
        self.history['layout_file'].append(layout_file)
        self.history['thermal_image'].append(thermal_image)
        self.history['acceptance'].append(acceptance)
        self.history['time'].append(elapsed_time)
        self.history['chip_area'].append(chip_area)
        self.history['score'].append(score)
        
        # 记录原始数据
        with open(self.raw_data_file, "a") as f:
            f.write(f"{iteration}\t{temperature}\t{wire_length}\n")
            
        with open(os.path.join(self.results_dir, "optimization_history.csv"), "a") as f:
            score_str = f"{score:.4f}" if score is not None else "NaN"
            # 使用相对路径保存布局文件路径
            rel_layout_path = os.path.relpath(layout_file, self.results_dir) if layout_file else ""
            f.write(f"{iteration},{temperature},{wire_length},{combined_cost},{rel_layout_path},{thermal_image},{acceptance},{elapsed_time},{chip_area},{score_str}\n")
        
        # 更新图表
        fig, ax1 = plt.subplots(figsize=(12, 8))
        ax1.plot(self.history['iteration'], self.history['temperature'], 'bo-', label='Temperature')
        ax1.set_xlabel('Iteration')
        ax1.set_ylabel('Max Temperature (K)', color='b')
        ax1.tick_params(axis='y', labelcolor='b')
        ax1.grid(True)
        ax2 = ax1.twinx()
        ax2.plot(self.history['iteration'], self.history['wire_length'], 'g-', label='Wire Length')
        ax2.set_ylabel('Average Wire Length', color='g')
        ax2.tick_params(axis='y', labelcolor='g')
        ax3 = ax1.twinx()
        ax3.spines['right'].set_position(('outward', 60))
        ax3.plot(self.history['iteration'], self.history['combined_cost'], 'r--', label='Combined Cost')
        ax3.set_ylabel('Combined Cost', color='r')
        ax3.tick_params(axis='y', labelcolor='r')
        plt.title('Optimization Progress')
        lines, labels = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        lines3, labels3 = ax3.get_legend_handles_labels()
        ax1.legend(lines + lines2 + lines3, labels + labels2 + labels3, loc='best')
        plt.savefig(os.path.join(self.results_dir, "optimization_history.png"))
        plt.close()

    # 计算归一化分数（对温度和布线长度进行赋分处理）
    def calculate_normalized_scores(self, temps, wires, temp_weight=0.6, wire_weight=0.4):
        valid_temps = [t for t in temps if t != float('inf')]
        valid_wires = [w for w in wires if w != float('inf')]
        
        if not valid_temps or not valid_wires:
            return [0] * len(temps)
        
        min_temp = min(valid_temps)
        max_temp = max(valid_temps)
        min_wire = min(valid_wires)
        max_wire = max(valid_wires)
        
        # 处理可能为0的差异（防止除以0）
        temp_range = max_temp - min_temp
        if temp_range < 1e-9:
            temp_range = 1.0
            
        wire_range = max_wire - min_wire
        if wire_range < 1e-9:
            wire_range = 1.0
        
        # 温度分数：温度越低分数越高（最低温度100分，最高温度0分）
        temp_scores = [100 * (1 - (t - min_temp) / temp_range) if t != float('inf') else 0 for t in temps]
        
        # 布线分数：布线越短分数越高（最短布线100分，最长布线0分）
        wire_scores = [100 * (1 - (w - min_wire) / wire_range) if w != float('inf') else 0 for w in wires]
        
        # 计算综合分数
        total_scores = [
            temp_weight * ts + wire_weight * ws
            for ts, ws in zip(temp_scores, wire_scores)
        ]
        
        return total_scores

    def generate_html_report(self):
        if not self.history['temperature']:
            print("警告: 没有足够的数据生成报告")
            return
            
        # 使用新评分系统选择最优解（只作为最后评估优化解中的最优解，并没有作为模拟退火算法中的评价体系）
        total_scores = self.calculate_normalized_scores(
            self.history['temperature'],
            self.history['wire_length'],
            self.config.get("temperature_weight", 0.6),
            self.config.get("wire_weight", 0.4)
        )
        
        best_score = max(total_scores) if total_scores else 0
        best_idx = total_scores.index(best_score) if total_scores else 0
        best_iter = self.history['iteration'][best_idx] if self.history['iteration'] else 0
        best_temp = self.history['temperature'][best_idx] if self.history['temperature'] else 0
        best_wire = self.history['wire_length'][best_idx] if self.history['wire_length'] else 0
        best_area = self.history['chip_area'][best_idx] if self.history['chip_area'] else 0
        
        initial_temp = self.history['temperature'][0] if self.history['temperature'] else 0
        initial_wire = self.history['wire_length'][0] if self.history['wire_length'] else 0
        initial_area = self.history['chip_area'][0] if self.history['chip_area'] else 0
        
        area_change = best_area - initial_area
        area_change_percent = (area_change / initial_area) * 100 if initial_area > 0 else 0
        wire_change = best_wire - initial_wire
        wire_change_percent = (wire_change / initial_wire) * 100 if initial_wire > 0 else 0
        temp_change = best_temp - initial_temp
        temp_change_percent = (temp_change / initial_temp) * 100 if initial_temp > 0 else 0
        
        # 确保有有效的数值
        best_temp_display = f"{best_temp:.2f}" if best_temp != float('inf') else "N/A"
        best_wire_display = f"{best_wire:.2f}" if best_wire != float('inf') else "N/A"
        best_area_display = f"{best_area:.2f}" if best_area != float('inf') else "N/A"
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Chip Thermal and Wire Optimization Report</title>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }}
                .stats {{ background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }}
                .grid-container {{ display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }}
                .card {{ background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; }}
                .card h3 {{ margin-top: 0; color: #2c3e50; }}
                .iteration-grid {{ display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 20px; }}
                .iteration-card {{ background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; }}
                .iteration-card h4 {{ margin-top: 0; }}
                .iteration-card img {{ max-width: 100%; border: 1px solid #ddd; border-radius: 3px; }}
                .best {{ border: 2px solid #27ae60; }}
                .temperature-history {{ width: 100%; }}
                .summary-table {{ width: 100%; border-collapse: collapse; }}
                .summary-table th, .summary-table td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                .summary-table th {{ background-color: #f2f2f2; }}
                .acceptance {{ font-weight: bold; }}
                .accepted {{ color: #27ae60; }}
                .rejected {{ color: #e74c3c; }}
                .score {{ font-weight: bold; color: #2980b9; }}
                .change {{ font-weight: bold; }}
                .improvement {{ color: #27ae60; }}
                .deterioration {{ color: #e74c3c; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>Chip Thermal and Wire Optimization Report</h1>
                    <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                </div>
                <div class="stats">
                    <h2>Optimization Summary</h2>
                    <table class="summary-table">
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Total Iterations</td>
                            <td>{len(self.history['iteration'])}</td>
                        </tr>
                        <tr>
                            <td>Best Score (New System)</td>
                            <td class="score">{best_score:.2f} (Iteration {best_iter})</td>
                        </tr>
                        <tr>
                            <td>Initial Temperature</td>
                            <td>{initial_temp:.2f} K</td>
                        </tr>
                        <tr>
                            <td>Best Temperature</td>
                            <td>{best_temp_display} K <span class="change {'improvement' if best_temp < initial_temp else 'deterioration'}">({temp_change:+.2f} K, {temp_change_percent:+.1f}%)</span></td>
                        </tr>
                        <tr>
                            <td>Initial Wire Length</td>
                            <td>{initial_wire:.2f}</td>
                        </tr>
                        <tr>
                            <td>Best Wire Length</td>
                            <td>{best_wire_display} <span class="change {'improvement' if best_wire < initial_wire else 'deterioration'}">({wire_change:+.2f}, {wire_change_percent:+.1f}%)</span></td>
                        </tr>
                        <tr>
                            <td>Initial Chip Area</td>
                            <td>{initial_area:.2f} mm²</td>
                        </tr>
                        <tr>
                            <td>Best Chip Area</td>
                            <td>{best_area_display} mm² <span class="change {'improvement' if best_area < initial_area else 'deterioration'}">({area_change:+.2f} mm², {area_change_percent:+.1f}%)</span></td>
                        </tr>
                        <tr>
                            <td>Total Optimization Time</td>
                            <td>{sum(self.history['time']):.1f} seconds</td>
                        </tr>
                        <tr>
                            <td>Acceptance Rate</td>
                            <td>{sum(self.history['acceptance']) / len(self.history['acceptance']) * 100:.1f}%</td>
                        </tr>
                    </table>
                    <h2>Optimization History</h2>
                    <img class="temperature-history" src="optimization_history.png" alt="Optimization History">
                </div>
                <div class="grid-container">
                    <div class="card">
                        <h3>Best Solution (Score: {best_score:.2f})</h3>
                        <img src="{self.history['thermal_image'][best_idx] if best_idx < len(self.history['thermal_image']) else ''}" alt="Best Thermal Map">
                        <p>Iteration: {best_iter}, Temperature: {best_temp_display} K</p>
                        <p>Wire Length: {best_wire_display}</p>
                        <p>Chip Area: {best_area_display} mm²</p>
                    </div>
                    <div class="card">
                        <h3>Initial Solution</h3>
                        <img src="{self.history['thermal_image'][0] if self.history['thermal_image'] else ''}" alt="Initial Thermal Map">
                        <p>Iteration: 0, Temperature: {initial_temp:.2f} K</p>
                        <p>Wire Length: {initial_wire:.2f}</p>
                        <p>Chip Area: {initial_area:.2f} mm²</p>
                    </div>
                </div>
                <h2>Iteration History</h2>
                <div class="iteration-grid">
        """
        for i in range(len(self.history['iteration'])):
            iteration = self.history['iteration'][i]
            temp = self.history['temperature'][i]
            wire = self.history['wire_length'][i]
            cost = self.history['combined_cost'][i]
            score_val = total_scores[i] if i < len(total_scores) else "N/A"
            layout_file = self.history['layout_file'][i]
            thermal_image = self.history['thermal_image'][i]
            accepted = "Accepted" if self.history['acceptance'][i] else "Rejected"
            chip_area = self.history['chip_area'][i]
            thumbnail = thermal_image
            if thermal_image:
                thumbnail_dir = os.path.dirname(thermal_image)
                thumbnail_path = os.path.join(thumbnail_dir, "thumbnail.png")
                if os.path.exists(thumbnail_path):
                    thumbnail = thumbnail_path
                    
            # 确保有有效的数值
            temp_display = f"{temp:.2f}" if temp != float('inf') else "N/A"
            wire_display = f"{wire:.2f}" if wire != float('inf') else "N/A"
            area_display = f"{chip_area:.2f}" if chip_area != float('inf') else "N/A"
            
            html += f"""
                    <div class="iteration-card {'best' if i == best_idx else ''}">
                        <h4>Iteration {iteration}</h4>
                        <p class="score">Score: {score_val:.2f}</p>
                        <p>Temperature: {temp_display} K</p>
                        <p>Wire Length: {wire_display}</p>
                        <p>Combined Cost: {cost:.4f}</p>
                        <p>Chip Area: {area_display} mm²</p>
                        <p>Status: <span class="acceptance {'accepted' if self.history['acceptance'][i] else 'rejected'}">{accepted}</span></p>
                        <img src="{thumbnail}" alt="Thermal Map Iteration {iteration}">
                        <p>Layout: {os.path.basename(layout_file)}</p>
                    </div>
            """
        html += """
                </div>
            </div>
        </body>
        </html>
        """
        with open(os.path.join(self.results_dir, "report.html"), "w") as f:
            f.write(html)
        return best_idx

    def optimize(self):
        initial_temp = self.config.get("initial_temp", 100.0)
        cooling_rate = self.config.get("cooling_rate", 0.95)
        max_iterations = self.config.get("max_iterations", 30)
        layout_file = self.config.get("layout_file", "ev6.flp")
        expansion_factor = self.config.get("expansion_factor", 1.1)
        temperature_weight = self.config.get("temperature_weight", 0.6)
        wire_weight = self.config.get("wire_weight", 0.4)
        
        if not os.path.exists(layout_file):
            print(f"错误: 找不到布局文件 {layout_file}")
            return
            
        blocks = self.parse_flp(layout_file)
        chip_width, chip_height = self.get_chip_bounds(blocks)
        initial_area = self.calculate_chip_area(blocks)
        
        print("运行初始仿真...")
        # 返回当前配置文件路径
        current_temp, thermal_img, elapsed_time, iter_layout_file = self.run_hotspot_simulation(0, layout_file)
        initial_wire_length = self.calculate_wire_length(blocks)
        initial_cost = (current_temp * temperature_weight) + (initial_wire_length * wire_weight)
        
        self.save_iteration_data(0, current_temp, initial_wire_length, initial_cost,
                                iter_layout_file, thermal_img, True, elapsed_time, initial_area)
        
        print(f"初始温度: {current_temp:.2f} K")
        print(f"初始布线长度: {initial_wire_length:.2f}")
        print(f"初始综合成本: {initial_cost:.4f}")
        print(f"初始芯片面积: {initial_area:.2f} mm²")
        
        best_temp = current_temp
        best_wire = initial_wire_length
        best_cost = initial_cost
        best_blocks = [b.copy() for b in blocks]
        current_blocks = [b.copy() for b in blocks]
        
        print(f"\n开始优化，共 {max_iterations} 次迭代...")
        print(f"芯片面积扩展因子: {expansion_factor}")
        print(f"优化权重: 温度={temperature_weight}, 布线长度={wire_weight}")
        
        for i in range(1, max_iterations + 1):
            print(f"\n迭代 {i}/{max_iterations}:")
            new_blocks = self.perturb_layout(current_blocks, chip_width, chip_height, expansion_factor)
            temp_file = f"temp_{i}.flp"
            self.write_flp(temp_file, new_blocks)
            new_area = self.calculate_chip_area(new_blocks)
            
            print("运行热仿真...")
            # 现在返回布局文件路径
            new_temp, thermal_img, elapsed_time, iter_layout_file = self.run_hotspot_simulation(i, temp_file)
            new_wire_length = self.calculate_wire_length(new_blocks)
            new_cost = (new_temp * temperature_weight) + (new_wire_length * wire_weight)
            
            # 使用以温度为主导的评价体系进行接受决策
            delta_cost = new_cost - best_cost
            accept_prob = min(1.0, math.exp(-delta_cost / initial_temp))
            accepted = False
            
            if delta_cost < 0 or random.random() < accept_prob:
                accepted = True
                current_temp = new_temp
                current_blocks = new_blocks
                if new_cost < best_cost:
                    best_temp = new_temp
                    best_wire = new_wire_length
                    best_cost = new_cost
                    best_blocks = [b.copy() for b in current_blocks]
                    print(f"新最佳综合成本: {best_cost:.4f}")
            
            # 保存数据 - 使用迭代目录中的布局文件路径
            self.save_iteration_data(i, new_temp, new_wire_length, new_cost,
                                    iter_layout_file, thermal_img,
                                    accepted, elapsed_time, new_area)
            
            print(f"温度: {new_temp:.2f} K, 布线长度: {new_wire_length:.2f}, 综合成本: {new_cost:.4f}")
            print(f"芯片面积: {new_area:.2f} mm², 耗时: {elapsed_time:.1f}秒, 状态: {'接受' if accepted else '拒绝'}")
            
            # 降温
            initial_temp *= cooling_rate
            
            if os.path.exists(temp_file):
                os.remove(temp_file)
        
        # 保存最佳布局（基于模拟退火算法的评价体系）
        best_layout_path = os.path.join(self.results_dir, "best_layout.flp")
        self.write_flp(best_layout_path, best_blocks)
        
        # 所有迭代结束后，计算分数并选择最优解（基于归一化评分系统）（寻找该组优化解中的最优解）
        print("\n所有迭代完成，计算归一化分数...")
        total_scores = self.calculate_normalized_scores(
            self.history['temperature'],
            self.history['wire_length'],
            self.config.get("temperature_weight", 0.6),
            self.config.get("wire_weight", 0.4)
        )
        
        # 更新历史记录中的分数
        for i, score in enumerate(total_scores):
            self.history['score'][i] = score
            # 更新CSV文件中的分数
            csv_path = os.path.join(self.results_dir, "optimization_history.csv")
            if os.path.exists(csv_path):
                with open(csv_path, "r") as f:
                    lines = f.readlines()
                if i < len(lines) - 1:  # 跳过标题行
                    parts = lines[i+1].strip().split(',')
                    if len(parts) >= 10:  # 确保有足够的列
                        parts[9] = f"{score:.4f}"  # 第10列是分数
                        lines[i+1] = ','.join(parts)
                with open(csv_path, "w") as f:
                    f.write('\n'.join(lines))
        
        best_score = max(total_scores) if total_scores else 0
        best_idx = total_scores.index(best_score) if total_scores else 0
        
        # 保存归一化评分系统下的最优布局
        if self.history['layout_file']:
            new_best_layout_path = os.path.join(self.results_dir, "new_best_layout.flp")
            # 直接从历史记录中获取布局文件路径
            best_layout_file = self.history['layout_file'][best_idx]
            if os.path.exists(best_layout_file):
                shutil.copy(best_layout_file, new_best_layout_path)
                print(f"新评分系统最优布局保存至: {new_best_layout_path}")
            else:
                print(f"警告: 找不到布局文件 {best_layout_file}")
        
        print("\n生成优化报告...")
        self.generate_html_report()
        
        if self.history['iteration']:
            final_temp = self.history['temperature'][best_idx] if best_idx < len(self.history['temperature']) else 0
            final_wire = self.history['wire_length'][best_idx] if best_idx < len(self.history['wire_length']) else 0
            final_area = self.history['chip_area'][best_idx] if best_idx < len(self.history['chip_area']) else 0
            initial_temp_val = self.history['temperature'][0] if self.history['temperature'] else 0
            initial_wire_val = self.history['wire_length'][0] if self.history['wire_length'] else 0
            initial_area_val = self.history['chip_area'][0] if self.history['chip_area'] else 0
            
            temp_change = final_temp - initial_temp_val
            temp_change_percent = (temp_change / initial_temp_val) * 100 if initial_temp_val > 0 else 0
            wire_change = final_wire - initial_wire_val
            wire_change_percent = (wire_change / initial_wire_val) * 100 if initial_wire_val > 0 else 0
            area_change = final_area - initial_area_val
            area_change_percent = (area_change / initial_area_val) * 100 if initial_area_val > 0 else 0
            
            print("\n" + "="*70)
            print(f"优化完成! 使用原有评价体系选择最优解，新评分系统用于最终评估")
            if self.history['combined_cost']:
                best_old_idx = self.history['combined_cost'].index(min(self.history['combined_cost']))
                print(f"模拟退火算法评价体系最优解: 迭代 {best_old_idx}")
            print(f"归一化评分系统最优解: 迭代 {best_idx}: 分数 = {best_score:.2f}")
            print(f"初始温度: {initial_temp_val:.2f} K -> 最终温度: {final_temp:.2f} K ({temp_change_percent:+.1f}%)")
            print(f"初始布线长度: {initial_wire_val:.2f} -> 最终布线长度: {final_wire:.2f} ({wire_change_percent:+.1f}%)")
            print(f"初始芯片面积: {initial_area_val:.2f} mm² -> 最终芯片面积: {final_area:.2f} mm² ({area_change_percent:+.1f}%)")
            print(f"原有评价体系最优布局保存至: {best_layout_path}")
            print(f"完整结果保存至: {self.results_dir}")
            print(f"HTML报告: {os.path.join(self.results_dir, 'report.html')}")
            print(f"原始数据文件: {self.raw_data_file}")
            print("="*70)

if __name__ == "__main__":
    config = {
        "layout_file": "ev6.flp",
        "type_file": "ev6.type",
        "initial_temp": 100.0,
        "cooling_rate": 0.95,
        "max_iterations": 30,
        "expansion_factor": 1.1,
        "temperature_weight": 0.6,  # 温度权重
        "wire_weight": 0.4          # 布线权重
    }
    
    print("="*70)
    print("芯片热优化与布线分析系统 - 自动化布局设计 ")
    print("="*70)
    print("本系统使用双评价体系:")
    print("1. 模拟退火过程使用以温度为主导的评价体系 (综合成本 = 温度*权重1 + 布线*权重2)")
    print("2. 最终选择最优解使用归一化评分系统 (充分考虑布线的影响)")
    print("3. 归一化评分系统: 温度分数 = 100 * (1 - (T - T_min)/(T_max - T_min))")
    print("4. 归一化评分系统: 布线分数 = 100 * (1 - (W - W_min)/(W_max - W_min))")
    print("5. 总分数 = 0.6 * 温度分数 + 0.4 * 布线分数")
    print("="*70)
    print(f"芯片面积扩大因子: {config['expansion_factor']}")
    print(f"优化权重: 温度={config['temperature_weight']}, 布线长度={config['wire_weight']}")
    print("="*70)
    
    required_files = ["run.sh", "example.config", "gcc.ptrace",
                     "example.materials", "ev6.flp", "ev6.type"]
    missing_files = [f for f in required_files if not os.path.exists(f)]
    if missing_files:
        print("错误: 缺少必要文件:")
        for f in missing_files:
            print(f" - {f}")
        print("请确保这些文件在当前目录中")
        exit(1)
        
    optimizer = LayoutOptimizer(config)
    optimizer.optimize()