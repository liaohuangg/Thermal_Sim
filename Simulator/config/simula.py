#!/usr/bin/env python3
import subprocess
import os
import re
import random
import time
import shutil
import matplotlib.pyplot as plt
from datetime import datetime
import csv
import glob
from PIL import Image

class Block:
    def __init__(self, name, width, height, x, y):
        self.name = name
        self.width = float(width)
        self.height = float(height)
        self.x = float(x)
        self.y = float(y)
    
    def __str__(self):
        return f"{self.name}\t{self.width:.6f}\t{self.height:.6f}\t{self.x:.6f}\t{self.y:.6f}"
    
    def copy(self):
        return Block(self.name, self.width, self.height, self.x, self.y)

class LayoutOptimizer:
    def __init__(self, config):
        self.config = config
        self.results_dir = f"results_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.results_dir, exist_ok=True)
        
        # 初始化历史记录
        self.history = {
            'iteration': [],
            'temperature': [],
            'layout_file': [],
            'thermal_image': [],
            'acceptance': [],
            'time': []
        }
        
        # 创建CSV文件
        with open(os.path.join(self.results_dir, "optimization_history.csv"), "w") as f:
            f.write("Iteration,Temperature,LayoutFile,ThermalImage,Acceptance,Time\n")
    
    def parse_flp(self, filename):
        """解析FLP布局文件"""
        blocks = []
        with open(filename, 'r') as f:
            for line in f:
                if line.startswith('#') or not line.strip():
                    continue
                parts = line.split()
                if len(parts) == 5:
                    blocks.append(Block(parts[0], parts[1], parts[2], parts[3], parts[4]))
        return blocks
    
    def write_flp(self, filename, blocks):
        """写入FLP布局文件"""
        with open(filename, 'w') as f:
            f.write("# Floorplan generated by optimizer\n")
            f.write("# Format: <unit-name>\t<width>\t<height>\t<left-x>\t<bottom-y>\n\n")
            for block in blocks:
                f.write(f"{block}\n")
    
    def get_chip_bounds(self, blocks):
        """获取芯片边界尺寸"""
        width = max(block.x + block.width for block in blocks)
        height = max(block.y + block.height for block in blocks)
        return width, height
    
    def perturb_layout(self, blocks, chip_width, chip_height):
        """随机扰动布局"""
        new_blocks = [block.copy() for block in blocks]
        idx = random.randint(0, len(new_blocks) - 1)
        block = new_blocks[idx]
        
        # 计算安全移动范围
        max_x = chip_width - block.width
        max_y = chip_height - block.height
        
        # 生成新位置
        block.x = random.uniform(0, max_x)
        block.y = random.uniform(0, max_y)
        
        return new_blocks
    
    def run_hotspot_simulation(self, iteration, layout_file):
        """运行HotSpot热仿真（使用原有的run.sh）"""
        iter_dir = os.path.join(self.results_dir, f"iteration_{iteration:03d}")
        os.makedirs(iter_dir, exist_ok=True)
        
        # 准备文件
        shutil.copy(layout_file, os.path.join(iter_dir, "ev6.flp"))
        for file in ["run.sh", "example.config", "gcc.ptrace", "example.materials"]:
            if os.path.exists(file):
                shutil.copy(file, iter_dir)
        
        # 运行原有的run.sh脚本
        start_time = time.time()
        try:
            # 运行脚本
            subprocess.run(["./run.sh"], cwd=iter_dir, check=True)
            
            # 创建输出目录
            out_dir = os.path.join(iter_dir, "outputs")
            os.makedirs(out_dir, exist_ok=True)
            
            # 移动生成的输出文件
            for file in glob.glob(os.path.join(iter_dir, "gcc.*")):
                if os.path.isfile(file):
                    os.rename(file, os.path.join(out_dir, os.path.basename(file)))
            
            # 移动HotSpot生成的输出目录
            if os.path.exists(os.path.join(iter_dir, "outputs")):
                for file in os.listdir(os.path.join(iter_dir, "outputs")):
                    src = os.path.join(iter_dir, "outputs", file)
                    dst = os.path.join(out_dir, file)
                    if os.path.isfile(src):
                        shutil.move(src, dst)
            
            # 解析温度
            max_temp = 0.0
            steady_file = os.path.join(out_dir, "gcc.steady")
            if os.path.exists(steady_file):
                with open(steady_file, "r") as f:
                    for line in f:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 2:
                                try:
                                    temp = float(parts[1])
                                    max_temp = max(max_temp, temp)
                                except ValueError:
                                    continue
            
            # 获取热力图
            thermal_image = ""
            png_files = glob.glob(os.path.join(out_dir, "*.png"))
            if png_files:
                thermal_image = png_files[0]
                
                # 创建缩略图
                try:
                    img = Image.open(thermal_image)
                    img.thumbnail((300, 300))
                    thumbnail_path = os.path.join(out_dir, "thumbnail.png")
                    img.save(thumbnail_path)
                except Exception as e:
                    print(f"创建缩略图失败: {e}")
            
            elapsed_time = time.time() - start_time
            return max_temp, thermal_image, elapsed_time
        
        except Exception as e:
            print(f"仿真失败: {e}")
            elapsed_time = time.time() - start_time
            return float('inf'), "", elapsed_time
    
    def save_iteration_data(self, iteration, temperature, layout_file, thermal_image, acceptance, elapsed_time):
        """保存迭代数据"""
        self.history['iteration'].append(iteration)
        self.history['temperature'].append(temperature)
        self.history['layout_file'].append(layout_file)
        self.history['thermal_image'].append(thermal_image)
        self.history['acceptance'].append(acceptance)
        self.history['time'].append(elapsed_time)
        
        # 保存到CSV
        with open(os.path.join(self.results_dir, "optimization_history.csv"), "a") as f:
            f.write(f"{iteration},{temperature},{layout_file},{thermal_image},{acceptance},{elapsed_time}\n")
        
        # 绘制温度历史图
        plt.figure(figsize=(10, 6))
        plt.plot(self.history['iteration'], self.history['temperature'], 'bo-')
        plt.xlabel('Iteration')
        plt.ylabel('Max Temperature (K)')
        plt.title('Temperature Optimization Progress')
        plt.grid(True)
        plt.savefig(os.path.join(self.results_dir, "temperature_history.png"))
        plt.close()
    
    def generate_html_report(self):
        """生成HTML报告"""
        if not self.history['temperature']:
            print("警告: 没有足够的数据生成报告")
            return
            
        best_temp = min(self.history['temperature'])
        best_idx = self.history['temperature'].index(best_temp)
        best_iter = self.history['iteration'][best_idx]
        
        # 生成HTML内容
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Chip Thermal Optimization Report</title>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }}
                .stats {{ background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }}
                .grid-container {{ display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }}
                .card {{ background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; }}
                .card h3 {{ margin-top: 0; color: #2c3e50; }}
                .iteration-grid {{ display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 20px; }}
                .iteration-card {{ background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; }}
                .iteration-card h4 {{ margin-top: 0; }}
                .iteration-card img {{ max-width: 100%; border: 1px solid #ddd; border-radius: 3px; }}
                .best {{ border: 2px solid #27ae60; }}
                .temperature-history {{ width: 100%; }}
                .summary-table {{ width: 100%; border-collapse: collapse; }}
                .summary-table th, .summary-table td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                .summary-table th {{ background-color: #f2f2f2; }}
                .acceptance {{ font-weight: bold; }}
                .accepted {{ color: #27ae60; }}
                .rejected {{ color: #e74c3c; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>Chip Thermal Optimization Report</h1>
                    <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                </div>
                
                <div class="stats">
                    <h2>Optimization Summary</h2>
                    <table class="summary-table">
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Total Iterations</td>
                            <td>{len(self.history['iteration'])}</td>
                        </tr>
                        <tr>
                            <td>Initial Temperature</td>
                            <td>{self.history['temperature'][0]:.2f} K</td>
                        </tr>
                        <tr>
                            <td>Best Temperature</td>
                            <td>{best_temp:.2f} K (Iteration {best_iter})</td>
                        </tr>
                        <tr>
                            <td>Temperature Reduction</td>
                            <td>{self.history['temperature'][0] - best_temp:.2f} K</td>
                        </tr>
                        <tr>
                            <td>Total Optimization Time</td>
                            <td>{sum(self.history['time']):.1f} seconds</td>
                        </tr>
                        <tr>
                            <td>Acceptance Rate</td>
                            <td>{sum(self.history['acceptance']) / len(self.history['acceptance']) * 100:.1f}%</td>
                        </tr>
                    </table>
                    
                    <h2>Temperature History</h2>
                    <img class="temperature-history" src="temperature_history.png" alt="Temperature History">
                </div>
                
                <div class="grid-container">
                    <div class="card">
                        <h3>Best Thermal Result</h3>
                        <img src="{self.history['thermal_image'][best_idx]}" alt="Best Thermal Map">
                        <p>Iteration: {best_iter}, Temperature: {best_temp:.2f} K</p>
                    </div>
                    
                    <div class="card">
                        <h3>Initial Thermal Result</h3>
                        <img src="{self.history['thermal_image'][0]}" alt="Initial Thermal Map">
                        <p>Iteration: 0, Temperature: {self.history['temperature'][0]:.2f} K</p>
                    </div>
                </div>
                
                <h2>Iteration History</h2>
                <div class="iteration-grid">
        """
        
        # 添加迭代卡片
        for i in range(len(self.history['iteration'])):
            iteration = self.history['iteration'][i]
            temp = self.history['temperature'][i]
            layout_file = self.history['layout_file'][i]
            thermal_image = self.history['thermal_image'][i]
            accepted = "Accepted" if self.history['acceptance'][i] else "Rejected"
            
            # 使用缩略图
            thumbnail = thermal_image
            if thermal_image:
                thumbnail_dir = os.path.dirname(thermal_image)
                thumbnail_path = os.path.join(thumbnail_dir, "thumbnail.png")
                if os.path.exists(thumbnail_path):
                    thumbnail = thumbnail_path
            
            html += f"""
                    <div class="iteration-card {'best' if i == best_idx else ''}">
                        <h4>Iteration {iteration}</h4>
                        <p>Temperature: {temp:.2f} K</p>
                        <p>Status: <span class="acceptance {'accepted' if self.history['acceptance'][i] else 'rejected'}">{accepted}</span></p>
                        <img src="{thumbnail}" alt="Thermal Map Iteration {iteration}">
                        <p>Layout: {os.path.basename(layout_file)}</p>
                    </div>
            """
        
        html += """
                </div>
            </div>
        </body>
        </html>
        """
        
        # 写入文件
        with open(os.path.join(self.results_dir, "report.html"), "w") as f:
            f.write(html)
    
    def optimize(self):
        """执行优化过程"""
        # 读取配置
        initial_temp = self.config.get("initial_temp", 100.0)
        cooling_rate = self.config.get("cooling_rate", 0.95)
        max_iterations = self.config.get("max_iterations", 50)
        layout_file = self.config.get("layout_file", "ev6.flp")
        
        # 检查布局文件是否存在
        if not os.path.exists(layout_file):
            print(f"错误: 找不到布局文件 {layout_file}")
            return
        
        # 解析布局文件
        blocks = self.parse_flp(layout_file)
        chip_width, chip_height = self.get_chip_bounds(blocks)
        
        # 初始仿真
        print("运行初始仿真...")
        current_temp, thermal_img, elapsed_time = self.run_hotspot_simulation(0, layout_file)
        
        # 保存初始数据
        self.save_iteration_data(0, current_temp, layout_file, thermal_img, True, elapsed_time)
        print(f"初始温度: {current_temp:.2f} K")
        
        best_temp = current_temp
        best_blocks = [b.copy() for b in blocks]
        current_blocks = [b.copy() for b in blocks]
        
        # 优化循环
        print(f"\n开始优化，共 {max_iterations} 次迭代...")
        for i in range(1, max_iterations + 1):
            print(f"\n迭代 {i}/{max_iterations}:")
            
            # 生成新布局
            new_blocks = self.perturb_layout(current_blocks, chip_width, chip_height)
            temp_file = f"temp_{i}.flp"
            self.write_flp(temp_file, new_blocks)
            
            # 运行仿真
            print("运行热仿真...")
            new_temp, thermal_img, elapsed_time = self.run_hotspot_simulation(i, temp_file)
            
            # 接受概率计算
            delta_temp = new_temp - current_temp
            accept_prob = min(1.0, pow(2.718, -delta_temp / initial_temp))
            accepted = False
            
            # 更新状态
            if delta_temp < 0 or random.random() < accept_prob:
                accepted = True
                current_temp = new_temp
                current_blocks = new_blocks
                
                if new_temp < best_temp:
                    best_temp = new_temp
                    best_blocks = [b.copy() for b in current_blocks]
                    print(f"🔥 新最佳温度: {best_temp:.2f} K")
            
            # 保存迭代数据
            self.save_iteration_data(i, new_temp, f"iteration_{i:03d}/ev6.flp", thermal_img, accepted, elapsed_time)
            print(f"温度: {new_temp:.2f} K, 耗时: {elapsed_time:.1f}秒, 状态: {'接受' if accepted else '拒绝'}")
            
            # 降温
            initial_temp *= cooling_rate
            
            # 清理临时文件
            if os.path.exists(temp_file):
                os.remove(temp_file)
        
        # 保存最佳布局
        best_layout_path = os.path.join(self.results_dir, "best_layout.flp")
        self.write_flp(best_layout_path, best_blocks)
        
        # 生成报告
        print("\n生成优化报告...")
        self.generate_html_report()
        
        print("\n" + "="*50)
        print(f"优化完成! 最佳温度: {best_temp:.2f} K")
        print(f"最佳布局保存至: {best_layout_path}")
        print(f"完整结果保存至: {self.results_dir}")
        print(f"HTML报告: {os.path.join(self.results_dir, 'report.html')}")
        print("="*50)

# 检查布局是否重叠
def check_layout_overlap(layout_file_path):
    """
    检查布局文件中各单元是否存在位置重叠
    
    参数：
        layout_file_path (str): 布局文件的绝对路径或相对路径（如 "./chip_layout.flp"）
    
    返回：
        tuple: (is_overlap, overlap_pairs)
            - is_overlap (bool): 整体是否存在重叠（True=有重叠，False=无重叠）
            - overlap_pairs (list): 重叠的单元对列表，每个元素为 (单元1名称, 单元2名称)，无重叠时为空列表
    
    异常：
        FileNotFoundError: 若输入的文件路径不存在
        ValueError: 若文件内容格式不符合要求（如缺少必要字段）
    """
    # -------------------------- 1. 读取并解析布局文件 --------------------------
    units = {}  # 存储每个单元的边界信息：key=单元名，value=字典（left_x, right_x, bottom_y, top_y）
    
    try:
        with open(layout_file_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except FileNotFoundError:
        raise FileNotFoundError(f"布局文件不存在，请检查路径：{layout_file_path}")
    
    for line_num, line in enumerate(lines, start=1):  # line_num 用于定位错误行
        line = line.strip()
        # 跳过注释行和空行
        if not line or line.startswith("#"):
            continue
        
        # 解析每行内容（格式要求：<unit-name> <width> <height> <left-x> <bottom-y>）
        parts = line.split()
        if len(parts) != 5:
            raise ValueError(
                f"文件第 {line_num} 行格式错误（需5个字段），内容：{line}\n"
                "正确格式：<unit-name> <width> <height> <left-x> <bottom-y>"
            )
        
        # 提取字段并转换为数值（处理类型错误）
        try:
            unit_name = parts[0]
            width = float(parts[1])
            height = float(parts[2])
            left_x = float(parts[3])
            bottom_y = float(parts[4])
        except ValueError:
            raise ValueError(
                f"文件第 {line_num} 行数值格式错误，内容：{line}\n"
                "width/height/left-x/bottom-y 需为数字（如 0.100000）"
            )
        
        # 计算单元的右边界和上边界
        right_x = left_x + width
        top_y = bottom_y + height
        
        # 检查单元名是否重复（避免重复解析覆盖）
        if unit_name in units:
            raise ValueError(f"文件中存在重复单元名：{unit_name}（第 {line_num} 行）")
        
        units[unit_name] = {
            "left_x": left_x,
            "right_x": right_x,
            "bottom_y": bottom_y,
            "top_y": top_y
        }
    
    # 若文件中无有效单元（仅注释/空行），返回无重叠
    if not units:
        print("警告：布局文件中未解析到任何有效单元（仅注释或空行）")
        return (False, [])
    
    # -------------------------- 2. 判断单元间是否重叠 --------------------------
    def _is_two_units_overlap(unit1_bounds, unit2_bounds):
        """内部函数：判断两个单元的边界是否重叠（分离轴定理）"""
        # 若x轴无交集 或 y轴无交集，则不重叠
        x_no_overlap = (unit1_bounds["right_x"] <= unit2_bounds["left_x"]) or \
                       (unit1_bounds["left_x"] >= unit2_bounds["right_x"])
        y_no_overlap = (unit1_bounds["top_y"] <= unit2_bounds["bottom_y"]) or \
                       (unit1_bounds["bottom_y"] >= unit2_bounds["top_y"])
        return not (x_no_overlap or y_no_overlap)
    
    overlap_pairs = []
    unit_names = list(units.keys())
    
    # 遍历所有单元对（避免重复检查：i < j，只检查每个对一次）
    for i in range(len(unit_names)):
        unit1_name = unit_names[i]
        unit1_bounds = units[unit1_name]
        
        for j in range(i + 1, len(unit_names)):
            unit2_name = unit_names[j]
            unit2_bounds = units[unit2_name]
            
            if _is_two_units_overlap(unit1_bounds, unit2_bounds):
                overlap_pairs.append((unit1_name, unit2_name))
    
    # -------------------------- 3. 返回结果 --------------------------
    is_overlap = len(overlap_pairs) > 0
    return (is_overlap, overlap_pairs)

if __name__ == "__main__":
    # 配置参数
    config = {
        "layout_file": "ev6.flp",          # 布局文件
        "initial_temp": 100.0,             # 初始温度（模拟退火）
        "cooling_rate": 0.95,               # 降温速率
        "max_iterations": 2                # 最大迭代次数（建议20-50）
    }
    
    # 显示欢迎信息
    # print("="*50)
    # print("芯片热优化系统 - 自动化布局设计")
    # print("="*50)
    # print("本系统将自动进行以下操作:")
    # print("1. 读取初始布局文件 (ev6.flp)")
    # print("2. 运行热仿真获取初始温度")
    # print("3. 使用模拟退火算法优化布局")
    # print("4. 每次迭代生成新布局并运行热仿真")
    # print("5. 记录所有迭代结果并生成可视化报告")
    # print("="*50)
    
    # 检查必要文件
    required_files = ["run.sh", "example.config", "gcc.ptrace", "example.materials", "ev6.flp"]
    missing_files = [f for f in required_files if not os.path.exists(f)]
    
    if missing_files:
        print("错误: 缺少必要文件:")
        for f in missing_files:
            print(f" - {f}")
        print("请确保这些文件在当前目录中")
        exit(1)
    
    # 检查布局不重叠
    # 2. 调用函数检查重叠
    layout_path = "ev6.flp"  # 假设布局文件在当前目录下，名为 chip_layout.flp
    try:
        has_overlap, overlap_units = check_layout_overlap(layout_path)
    except (FileNotFoundError, ValueError) as e:
        print(f"检查失败：{e}")
    else:
        # 3. 输出结果
        if has_overlap:
            print(f"布局文件 {layout_path} 中存在 {len(overlap_units)} 组单元重叠：")
            for idx, (unit1, unit2) in enumerate(overlap_units, start=1):
                print(f"  {idx}. {unit1} ↔ {unit2}")
        else:
            print(f"布局文件 {layout_path} 中所有单元无重叠，布局合法！")
    # 创建优化器并运行
    optimizer = LayoutOptimizer(config)
    optimizer.optimize()